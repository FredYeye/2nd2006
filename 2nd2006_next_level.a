.segment "HEADER"
	.byte "NES",$1A
	.byte 2 ;32K PRG
	.byte 1 ;8K CHR
	.byte 0 ;vertical arrangement and stuff

.segment "TILES"
	.incbin "2nd2006.chr"

.segment "VECTORS"
	.word nmi, reset, irq

.segment "STARTUP" ; avoids warning
.segment "CODE"


nmi:
	bit $2002
	inx
	nop
	cmp ($00,X)
irq:
	rti

reset:
	sei
	cld


	;wait for ppu to get ready
	bit $2002
vwait1:
	bit $2002
	bpl vwait1
vwait2:
	bit $2002
	bpl vwait2


	;disable rendering
	lda #$00
	sta $2001


	;initialize ram for timing adjustment, scanline and dot*3 offset
	sta $00
	sta $04
	sta $05


	;set BG palette
	lda #$3F
	sta $2006
	lda #$00
	sta $2006

	lda #$0F    ;BG0:0 - black
	sta $2007
	lda #$20    ;BG0:1 - white
	sta $2007
	lda #$25    ;BG0:2 - pink
	sta $2007
	lda #$29    ;BG0:3 - green
	sta $2007


	;clear nametables
	lda #$24
	sta $2006
	lda #$00
	sta $2006

	ldy #$10
clearNT2:
	ldx #$80
clearNT:
	sta $2007
	dex
	bne clearNT
	dey
	bne clearNT2


	;set NT0 and add a row of triangles
	lda #$20
	sta $2006
	lda #$0C
	sta $2006

	lda #$01
	ldx #$08
nt:
	sta $2007
	dex
	bne nt


	;set NT1 and add a row of Y-2 offset triangles
	lda #$28
	sta $2006
	lda #$0C
	sta $2006

	lda #$02
	ldx #$08
nt2:
	sta $2007
	dex
	bne nt2


	;put some text on screen
	lda #$29
	sta $2006
	lda #$60
	sta $2006
nt3:
	lda text,X
	sta $2007
	inx
	cpx #$40
	bne nt3


	;wait for bit $2002 to return 1 without the nmi firing.
	;then, run the sync loop once more because the second frame might test one dot earlier? which would be dot 0.
	;now, the write loop should be entered at the same cpu-ppu sync every time (barring different alignments thinking otherwise).
	lda #$80
	sta $2000
sync2:
	cmp ($00,X)
	cmp ($00,X)
	cmp $00,X
	bit $2002
	bit $2002
	bpl sync2
	cpx #$00
	beq correctSync
	ldx #$00
	cmp ($00,X)
	cmp ($00,X)
	pha
	pla
	jmp sync2
correctSync:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	lsr $FF
sync3:
	cmp ($00,X)
	cmp ($00,X)
	cmp $00,X
	bit $2002
	bit $2002
	bpl sync3


	;idle
	cmp ($00,X)
	cmp ($00,X)
	cmp $00,X


	;enable rendering & disable nmi
	lda #$0A
	sta $2001
	lda #$00
	sta $2000


	;wait for vblank
sync:
	cmp ($00,X)
	cmp ($00,X)
	cmp $00,X
	bit $2002
	bit $2002
	bpl sync


	;offset value to print, 26 cycles
	lda $05
	clc
	bne mul3
	lsr $FF
	jmp skipa
mul3:
	adc #$02
	cmp #$03
	beq skipa
	adc #$01
	jmp add
skipa:
	cmp $00,X
add:
	clc
	adc $04
	ora #$10

	;print location, 16 cycles
	ldx #$29
	stx $2006
	ldx #$89
	stx $2006
	sta $2007


	;draw from NT0
	lda #$00
	sta $2006
	sta $2006


	;get buttons, 144 cycles total
	;store old buttons
	lda $01
	sta $02

	;read buttons
	lda #$01
	sta $01
	sta $4016
	lsr
	sta $4016
readButtons:
	lda $4016
	lsr
	rol $01
	bcc readButtons

	;only read new button presses and store them
	lda $01
	eor $02
	and $01
	sta $03


	;increase dot delay, 38 cycles
	lda $03
	and #$01
	beq rightNotPressed
	lda #$02
	cmp $04
	beq carry
	inc $04
	cmp ($00,X)
	cmp ($00,X)
	cmp $00,X
	jmp done
carry:
	lda #$00
	sta $04
	lda #$02
	cmp $05
	beq carry2
	inc $05
	cmp $00
	jmp done
carry2:
	lda #$00
	sta $05
	nop
	jmp done
rightNotPressed:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
done:

	;decrease dot delay, 33 cycles
	ldx #$02
	lda $03
	and #$02
	beq leftNotPressed
	lda $04
	beq carry3
	dec $04
	cmp ($00,X)
	lsr $FF
	jmp done2
carry3:
	stx $04
	lda $05
	beq carry4
	dec $05
	nop
	jmp done2
carry4:
	stx $05
	cmp $00
	jmp done2
leftNotPressed:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	lsr $FF
done2:


	;13, 13+114, or 13+228 cpu cycles
	ldx $04
	dex
	bmi skipWait
	jsr waitScanline
skipWait:
	dex
	bmi skipWait2
	jsr waitScanline
skipWait2:

	;13, 14 or 15 cpu cycles
	ldx $05
	dex
	bmi skipWait3
	nop
skipWait3:
	dex
	bmi skipWait4
	nop
skipWait4:


	;wait until scanline 1,2 or 3 (waits 2 + 34*Y - 1 cycles)
	ldy #$42
wait:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	lsr $FF
	dey
	bne wait

	;can fine tune timing here
	cmp ($00,X)
	cmp $00,X


	;Y offset, 22 cycles
	lda #$08
	ldx $04
	dex
	clc
	bmi asd
	adc #$10
	dex
	bmi asd2
	adc #$10
	jmp asd3
asd:
	cmp ($00,X)
asd2:
	cmp $00,X
asd3:


	;first write to 2006
	sta $2006

	;second write
	lda #$00
	sta $2006


	;idle for timing, changes in the fine tune section needs to be compensated for here
	lsr $FF


	;scanline offset adjustment, 6, 27 or 21 cpu cycles
	lda $04
	beq skip
	cmp #$02
	beq scanlineAdjust
	pha
	pla
scanlineAdjust:
	cmp ($00,X)
	lsr $FF
skip:

	;dot*3 offset adjustment, 15, 14 or 13 cycles
	ldx $05
	dex
	bpl dotAdjust
	nop
dotAdjust:
	dex
	bpl dotAdjust2
	nop
dotAdjust2:


	;this diffs with 1 cpu cycle every other frame, takes 10-11 cpu cycles
	lda $00
	eor #$01
	sta $00
	beq adjust
adjust:
	jmp sync


;wait 109 cpu cycles
waitScanline:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	pha
	pla
	rts


text:
.byte $00,$2B,$24,$25,$33,$3D,$31,$28,$26,$27,$33,$3E,$00,$3B,$3A,$11
.byte $00,$23,$2E,$33,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
.byte $00,$2E,$25,$25,$32,$24,$33,$3E,$00,$00,$00,$00,$00,$00,$00,$00
