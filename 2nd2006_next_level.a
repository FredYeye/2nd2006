.segment "HEADER"
	.byte "NES",$1A
	.byte 2 ;32K PRG
	.byte 1 ;8K CHR
	.byte 0 ;vertical arrangement and stuff

.segment "TILES"
	.incbin "2nd2006.chr"

.segment "VECTORS"
	.word nmi, reset, irq

.segment "STARTUP" ; avoids warning
.segment "CODE"


nmi:
irq:
	rti

reset:
	sei
	cld


	;wait for ppu to get ready
	bit $2002
vwait1:
	bit $2002
	bpl vwait1
vwait2:
	bit $2002
	bpl vwait2


	;disable rendering
	lda #$00
	sta $2001


	;set BG palette
	lda #$3F
	sta $2006
	lda #$00
	sta $2006

	lda #$0F    ;BG0:0 - black
	sta $2007
	lda #$21    ;BG0:1 - blue
	sta $2007
	lda #$25    ;BG0:2 - pink
	sta $2007
	lda #$29    ;BG0:3 - green
	sta $2007


	;clear nametables
	lda #$24
	sta $2006
	lda #$00
	sta $2006

	ldy #$10
clearNT2:
	ldx #$80
clearNT:
	sta $2007
	dex
	bne clearNT
	dey
	bne clearNT2


	;set NT0 and draw some blue triangles
	lda #$20
	sta $2006
	lda #$00
	sta $2006

	lda #$01
	ldx #$20
nt:
	sta $2007
	dex
	bne nt


	;set NT1 and draw some pink, Y-2 offset triangles
	lda #$28
	sta $2006
	lda #$00
	sta $2006

	lda #$02
	ldx #$20
nt2:
	sta $2007
	dex
	bne nt2


	;enable rendering
	lda #$0A
	sta $2001


	;set up for timing adjustment, see "adjust:"
	lda #$00
	sta $00


	;idle to time first frame correctly
	cmp($00,X)
	cmp($00,X)
	cmp #$00

	;prepare scanline and dot*3 offset
	lda #$00
	sta $04
	sta $05

	;wait for vblank
sync:
	cmp ($00,X)
	cmp ($00,X)
	cmp $1000
	bit $2002
	bit $2002
	bpl sync


	;draw from NT0
	lda #$00
	sta $2006
	lda #$00
	sta $2006


	;wait from scanline 241 to 1 (waits 34*67-1 cycles)
	ldy #$43
wait:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp $00
	cmp #$00
	dey
	bne wait

	;can fine tune timing here


	;get buttons, 144 cycles total
	;store old buttons
	lda $01
	sta $02

	;read buttons
	lda #$01
	sta $01
	sta $4016
	lsr a
	sta $4016
readButtons:
	lda $4016
	lsr a
	rol $01
	bcc readButtons

	;only read new button presses and store them
	lda $01
	eor $02
	and $01
	sta $03


	;increase the scanline delay, 19 cycles
	and #$04
	beq downNotPressed
	lda $04
	sec
	rol
	and #$03
	sta $04
	jmp downUpdated
downNotPressed:
	cmp ($00,X)
	cmp ($00,X)
	cmp #$00
downUpdated:

	;decrease the scanline delay, 18 cycles
	lda $03
	and #$08
	beq upNotPressed
	lda $04
	lsr
	sta $04
	jmp upUpdated
upNotPressed:
	cmp ($00,X)
	cmp $1000
upUpdated:


	;move some idling here to prevent branches from page crossing
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)


	;increase the dot*3 delay, 22 cycles
	lda $03
	and #$01
	beq rightNotPressed
	lda $05
	sec
	rol
	and #$03
	sta $05
	jmp rightUpdated
rightNotPressed:
	cmp ($00,X)
	cmp ($00,X)
	cmp #$00
rightUpdated:

	;decrease the dot*3 delay, 18 cycles
	lda $03
	and #$02
	beq leftNotPressed
	lda $05
	lsr
	sta $05
	jmp leftUpdated
leftNotPressed:
	cmp ($00,X)
	cmp $1000
leftUpdated:


	;16, 16+114, or 16+228 cpu cycles
	lda #$01
	and $04
	beq skipWait
	jsr waitScanline
skipWait:
	lda #$02
	and $04
	beq skipWait2
	jsr waitScanline
skipWait2:


	;16, 17 or 18 cpu cycles
	lda #$01
	and $05
	beq skipWait3
	nop
skipWait3:
	lda #$02
	and $05
	beq skipWait4
	nop
skipWait4:


	;first write to 2006
	lda #$08
	sta $2006
	lda #$00


	;second write
	sta $2006


	;idle for timing, changes in the fine tune section needs to be compensated for here
	cmp #$00


	;scanline offset adjustment, 6, 27 or 20 cpu cycles, takes 6, 27 or 20 cpu cycles
	lda $04
	beq skip
	cmp #$01
	bne scanlineAdjust
	cmp ($00,X)
	cmp ($00,X)
	cmp $00
	jmp skip
scanlineAdjust:
	cmp #$03
	bne skip
	cmp $1000
	cmp $00
skip:

	;dot*3 offset adjustment    18,17,16?
	lda #$02
	and $05
	bne dotAdjust
	nop
dotAdjust:
	lda #$01
	and $05
	bne dotAdjust2
	nop
dotAdjust2:


	;this diffs with 1 cpu cycle every other frame, takes 10-11 cpu cycles
	lda $00
	eor #$01
	sta $00
	beq adjust
adjust:
	jmp sync


;wait 109 cpu cycles
waitScanline:
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp ($00,X)
	cmp $1000
	cmp $00
	rts
